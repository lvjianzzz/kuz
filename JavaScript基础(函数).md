# 函数(function)
就是将一些功能或语句进行封装，在需要的时候，通过调用的形式，执行这些语句
函数也是一个对象
+ 函数的定义
    + 使用函数声明来创建一个函数(具名函数)
    函数命名规则与变量命名规则相同
    ```
    function 函数名(形参){
        语句
    }
    函数名() //调用函数
    ```
    + 使用函数表达式来创建一个函数(匿名函数)
    所谓的“函数表达式”，其实就是将匿名函数赋值给一个变量
    ```
    var a  = function () {

    }
    a() //调用函数
    ```
    + 形参和实参
    ```
    function 函数名(形参1,形参2){
        // 多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值
        console.log(形参1+形参2)
    }
    函数名(实参1,实参2) //实参将会赋值给函数中对应的形参
    ```
        - 函数的实参可以是任意的数据类型
        - 调用函数时，解析器也不会检查实参的数量
        多余实参不会被赋值
        - 如果实参的数量少于形参的数量，则没有对应实参的形参将是 undefined。
    + 函数的返回值
        + return 后的值将会作为函数的执行结果返回
        + 常需要用一个变量来接收 函数的返回值
        + 在函数中 return 后的语句都不会执行（函数在执行完 return 语句之后停止并立即退出）
        + 如果 return 语句后不跟任何值，就相当于返回一个 undefined
        + 返回值可以是任意的数据类型，可以是对象，也可以是函数
        ```
        function sum(a, b) {
            return a + b;
            console.log(10);
        }
        var a = sum(5, 6);
        console.log(a);
        ```
    + 函数的作用域
        + 全局作用域(全局变量) 和 函数作用域(局部变量)
        + 在函数内声明的变量其作用范围仅在此函数内,在此函数外不可以引用该变量
        + 在全局作用域中
        创建的变量会作为window 对象的属性保存
        创建的函数会作为window 对象的方法保存
    + 作用于的上下级关系
        作用域查找 就近原则
        当函数在作用域操作一个变量时,它会先在自身的作用域寻找.如果有就直接使用(就近原则) 如果没有则向上一级作用域中寻找,直到找到全局作用域;
        如果全局作用域中依然没有找到,则会报错 ReferenceError
    + 变量和函数的声明提升
        + 变量一般为先声明后使用
        用var关键字声明变量时存在一个声明提升的特性,声明虽然提升但是赋值不会提升
        如果在赋值前用console.log(),则结果为undefined
        + 函数也存在声明提升
        只有使用函数声明创建的函数才具备这个特性(可以才函数声明前调用函数)
    + 立即执行函数
        ```
        (function(){
            alert('立即执行函数')
        })();
        ```
        函数定义完，立即被调用，这种函数叫做立即执行函数
        立即执行函数往往只会执行一次(因为没有变量保存它，执行完了之后，就找不到它了)
    + 参数的数据类型
        + 基本数据类型
        基本数据类型作为参数传递，函数内部会创建该数据的副本，一切修改不会影响传进来的数据本身(仅作为参数时如此)
        + 复杂数据类型
        复杂数据类型作为参数传递,在函数内部对该参数的修改，会直接影响到函数外部的该参数，因为本质上他们是同一个对象
        + 栈内存和堆内存
        JS 中，所有的变量都是保存在栈内存中的
        基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量
        引用数据类型保存在堆内存中的。变量只是保存了内存地址（对象的引用）。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响
    + 递归
        递归算法自己调用自己
        递归需要有跳出条件
        ```
        function jc(n) {
            if (n === 1) {
                return 1;
            }
            return n * jc(n - 1);
        } // 计算阶乘
        ```



